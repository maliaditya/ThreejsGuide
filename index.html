<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title"></title>
    <script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>

    <!-- Prism.js Theme for Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <!-- Highlight.js Theme for Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>

    <style>
        body {
            font-family: 'Roboto', Arial, Helvetica, sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            display: flex;
            justify-content: center;
            height: 100vh;
            overflow: auto;
        }

        #sidebar {
            margin-top: 30px;
            width: 280px;
            padding: 15px;
            border-right: 1px solid #3c3c3c;
            overflow-y: auto;
            height: 90%;
            position: relative;
            border-top-right-radius: 15px;
            border-bottom-right-radius: 15px;
            transition: transform 0.3s ease;
        }

        #sidebar.overlay {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            background-color: #1e1e1e;
            z-index: 2000;
            transform: translateX(-100%);
        }

        #sidebar.overlay.visible {
            transform: translateX(0);
        }

        #sidebar::-webkit-scrollbar {
            width: 8px;
        }

        #sidebar::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        #sidebar::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        #sidebar h3 {
            font-weight: bold;
            margin-bottom: 15px;
            color: #58a6ff;
        }

        #sidebar a {
            display: flex;
            align-items: center;
            color: #ffffff;
            padding: 10px;
            text-decoration: none;
            border-radius: 8px;
            margin-bottom: 10px;
            font-weight: bold;
            background:linear-gradient(to right, #7800ff, #9a31ff);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        #sidebar a:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
        }

        /* Guide sidebar grouped file styles (only filenames listed under groups) */
        .guide-group-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 8px 10px;
            border-radius: 8px;
            color: #e6eef6;
            transition: background 0.14s ease, transform 0.12s ease;
            margin-top: 8px;
            background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
        }

        .guide-group-header:hover { background: rgba(255,255,255,0.03); transform: translateY(-1px); }

        .guide-group-header .caret {
            color: #9aa7b2;
            font-size: 12px;
            width: 12px;
            display: inline-block;
            text-align: center;
            transition: transform 0.18s ease;
        }

        .guide-group-header.open { background: rgba(255,255,255,0.01); }
        .guide-group-header.open .caret { transform: rotate(90deg); color: #6a11cb; }

        .guide-group-contents {
            padding-left: 8px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.22s ease, opacity 0.18s ease;
            opacity: 0;
        }

        .guide-group-contents.open { max-height: 1000px; opacity: 1; }

        .guide-group-contents ul {
            list-style: none;
            margin: 6px 0 0 0;
            padding: 0;
            border-left: 1px solid rgba(255,255,255,0.03);
            padding-left: 12px;
        }

        .guide-group-contents li {
            margin-bottom: 6px;
        }

        .guide-group-contents a {
            color: #cfd6e0;
            font-size: 0.95em;
            text-decoration: none;
            padding: 6px 8px;
            display: block;
            border-radius: 6px;
            position: relative;
            transition: background 0.12s ease, color 0.12s ease;
            background: transparent;
        }

        .guide-group-contents a::before {
            content: '';
            position: absolute;
            left: -12px;
            top: 50%;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.03);
            transform: translateY(-50%);
            transition: background 0.12s ease;
        }

        /* hover: keep subtle, no full purple background */
        .guide-group-contents a:hover { background: transparent; color: #ffffff; }

        /* only active file gets the purple gradient */
        .guide-group-contents a.active {
            background: linear-gradient(90deg, #6a11cb, #2575fc);
            color: #ffffff;
            font-weight: 700;
            padding-left: 10px;
            padding-right: 14px;
        }

        .guide-group-contents a.active::before { background: #6a11cb; box-shadow: 0 0 8px rgba(106,17,203,0.18); }

        /* small temporary highlight for scrolled-to header */
        .preview-highlight {
            box-shadow: inset 0 -4px 0 0 rgba(106,17,203,0.3);
            transition: box-shadow 0.4s ease;
        }

        #content {
            margin: 0;
            padding: 30px;
            flex: 1;
            overflow-y: auto;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
        }

        #content::-webkit-scrollbar {
            width: 8px;
        }

        #content::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        #content::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        /* Global scrollbar styling to ensure consistent dark appearance */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }
        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        /* Firefox */
        html, body, #sidebar, #toc-sidebar, #slide-view {
            scrollbar-width: thin;
            scrollbar-color: #444 #1e1e1e;
        }

        /* Subtle sidebar separators: make them darker and less contrasty */
        #sidebar { border-right: 1px solid rgba(255,255,255,0.03); }
        #toc-sidebar { border-left: 1px solid rgba(255,255,255,0.03); }

        .preview-container {
            position: relative;
            border-radius: 50px;
            padding: 2px;
        }

        .preview-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 25px;
            padding: 2px;
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
        }

        #preview {
            position: relative;
            border-radius: 8px;
            background-color: #1e1e1e;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            color: #d4d4d4;
            overflow: hidden;
        }

        #preview img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            border-radius: 8px;
        }

        h1, h2, h3, h4, h5, h6 {
            background: linear-gradient(to right, #6a11cb, #2575fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        a {
            color: #56b6c2;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        code {
            background: #673ab7;
            color: #F8F8F2;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 1em;
            font-family: 'Courier New', Courier, monospace;
            display: inline-block;
        }

        pre {
            background-color: #2D2D2D;
            color: #F8F8F2;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid #44475a;
            font-size: 0.98em;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .token.comment,
        .token.prolog,
        .token.doctype,
        .token.cdata {
            color: #6272a4;
        }

        .token.punctuation {
            color: #f8f8f2;
        }

        .token.property,
        .token.tag,
        .token.constant,
        .token.symbol,
        .token.deleted {
            color: #ff79c6;
        }

        .token.boolean,
        .token.number {
            color: #bd93f9;
        }

        .token.selector,
        .token.attr-name,
        .token.string,
        .token.char,
        .token.builtin,
        .token.inserted {
            color: #50fa7b;
        }

        .token.operator,
        .token.entity,
        .token.url,
        .language-css .token.string,
        .style .token.string {
            color: #f1fa8c;
        }

        .token.atrule,
        .token.attr-value,
        .token.keyword {
            color: #8be9fd;
        }

        .token.function,
        .token.class-name {
            color: #66d9ef;
        }

        .token.regex,
        .token.important,
        .token.variable {
            color: #ffb86c;
        }

        .token.important,
        .token.bold {
            font-weight: bold;
        }

        .token.italic {
            font-style: italic;
        }

        .token.entity {
            cursor: help;
        }

        #toc-sidebar {
            margin-top: 30px;
            width: 280px;
            padding: 15px;
            border-left: 1px solid #3c3c3c;
            overflow-y: auto;
            height: fit-content;
            position: relative;
            border-top-left-radius: 15px;
            border-bottom-left-radius: 15px;
            margin-left: 20px;
            transition: transform 0.3s ease;
        }

        #toc-sidebar.overlay {
            position: fixed;
            top: 0;
            right: 0;
            height: 100%;
            background-color: #1e1e1e;
            z-index: 2000;
            transform: translateX(100%);
        }

        #toc-sidebar.overlay.visible {
            transform: translateX(0);
        }

        #toc-sidebar h3 {
            font-weight: bold;
            margin-bottom: 15px;
            color: #58a6ff;
        }

        #toc-sidebar a {
            display: block;
            color: #d4d4d4;
            padding: 8px 15px;
            text-decoration: none;
            border-radius: 5px;
            margin-bottom: 5px;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }

        #toc-sidebar a:hover {
            background-color: #3c3c3c;
        }

        #toc-sidebar a.active {
            background-color: #6a11cb;
            color: #ffffff;
        }

        /* Nested TOC styling (tightened) - dots removed, lines kept */
        #toc-list { position: relative; }
        #toc-list ul {
            list-style: none;
            margin: 0;
            padding-left: 0;
            position: relative;
        }

        /* reduce overall left spacing so connectors sit close to text */
        #toc-list li {
            margin-bottom: 6px;
            position: relative;
            padding-left: 12px; /* tightened */
        }

        /* vertical connector line for nested lists (thinner & closer) */
        #toc-list ul ul::before {
            content: '';
            position: absolute;
            left: 7px;
            top: 8px;
            bottom: 8px;
            width: 1px;
            background: rgba(255,255,255,0.03);
            border-radius: 1px;
        }

        /* remove circular dots - keep clean lines only */
        #toc-list li::before {
            display: none;
        }

        /* completed-toggle area (small, invisible button that sits over the dot) */
        .toc-complete-toggle {
            position: absolute;
            left: 2px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
        }

        /* small dot for each item (now visible) */
        #toc-list li::before {
            content: '';
            position: absolute;
            left: 6px;
            top: 50%;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.06);
            transform: translateY(-50%);
            transition: background-color 0.12s ease, transform 0.12s ease, box-shadow 0.12s ease;
        }

        /* smaller dots for nested levels */
        #toc-list ul ul li::before {
            width: 5px;
            height: 5px;
            left: 5px;
            background: rgba(255,255,255,0.05);
        }

        #toc-list ul ul ul li::before {
            width: 4px;
            height: 4px;
            left: 9px;
            background: rgba(255,255,255,0.04);
        }

        /* completed shows a small green check in place of the dot */
        #toc-list li.completed::before {
            width: 10px;
            height: 10px;
            left: 3px;
            background: #10b981 url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'><path d='M20.285 6.709l-11.025 11.02-5.545-5.546 1.414-1.414 4.131 4.132 9.611-9.618z'/></svg>") no-repeat center / 10px 10px;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(16,185,129,0.18);
            transform: translateY(-50%) scale(1.02);
        }

        /* add a subtle horizontal active indicator aligned with each item */
        #toc-list li::after {
            content: '';
            position: absolute;
            left: 20px;
            top: 50%;
            width: 0;
            height: 2px;
            background: transparent;
            transform: translateY(-50%);
            transition: width 0.12s ease, background 0.12s ease;
            border-radius: 2px;
        }

        #toc-list li.active::after {
            width: 10px;
            background: #6a11cb;
            box-shadow: 0 0 6px rgba(106,17,203,0.22);
        }

        /* show L-branch for items that have children */
        #toc-list li.has-children > a::before {
            content: '';
            position: absolute;
            left: 12px;
            top: 50%;
            width: 10px;
            height: 1px;
            background: rgba(255,255,255,0.03);
            transform: translateY(-50%);
        }

        #toc-list li a {
            display: block;
            color: #d4d4d4;
            padding: 6px 8px; /* tightened */
            text-decoration: none;
            border-radius: 5px;
            font-weight: 500;
            transition: background-color 0.15s ease;
        }

        #toc-list li a:hover {
            background-color: #3c3c3c;
        }

        /* nested connector adjustments */
        #toc-list ul ul::before {
            left: 11px;
        }

        #toc-list ul ul li a {
            padding-left: 18px;
            font-size: 0.95em;
            color: #cfd6e0;
        }

        #toc-list ul ul ul::before {
            left: 15px;
            background: rgba(255,255,255,0.02);
        }

        #toc-list ul ul ul li a {
            padding-left: 28px;
            font-size: 0.9em;
            color: #bfc8d8;
        }

        /* completed state visuals */
        #toc-list li.completed > a {
            opacity: 0.95;
            color: #dff7ea;
        }

        /* active link styles (for li.active) */
        #toc-list li.active > a {
            background-color: #6a11cb;
            color: #ffffff;
        }

        /* Slides button (bottom-right) */
        .slides-btn {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 4000;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            color: #fff;
            border: none;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
            font-weight: 600;
        }

        .slides-btn:hover { transform: translateY(-2px); }

        /* Slides overlay */
        .slides-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.75);
            z-index: 5000;
            padding: 40px;
        }

        .slides-overlay.open { display: flex; }

        .slides-inner {
            width: 80%;
            max-width: 900px;
            background: #151515;
            border-radius: 10px;
            padding: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            color: #e6eef6;
            position: relative;
            overflow: auto;
            max-height: 80vh;
        }

        .slide-content > h1, .slide-content > h2, .slide-content > h3 { margin-top: 0; }

        /* Keep images contained inside slides */
        .slide-content img,
        .slides-inner img,
        .slide-inline img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 12px auto;
            object-fit: contain;
        }
        /* Constrain very tall images so they fit inside overlay/inline slide scroll areas */
        .slides-inner img { max-height: calc(80vh - 160px); }
        .slide-inline img { max-height: calc(70vh - 160px); }

        /* Responsive video embeds (YouTube) */
        .video-embed {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 */
            height: 0;
            margin: 16px 0;
            overflow: hidden;
            border-radius: 6px;
            background: #000;
        }
        .video-embed iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
        }
        /* Constrain video height inside slide overlay */
        .slides-inner .video-embed { max-height: calc(80vh - 160px); }
        .slide-inline .video-embed { max-height: calc(70vh - 160px); }

        .video-fallback {
            text-align: center;
            margin-top: 8px;
            font-size: 0.95em;
            color: #9fbad8;
        }
        .video-fallback a { color: #58a6ff; text-decoration: underline; }

        .slide-controls {
            position: absolute;
            right: 12px;
            bottom: 12px;
            display: flex;
            gap: 8px;
        }

        .slide-btn {
            background: rgba(255,255,255,0.06);
            border: none;
            color: #d4d4d4;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
        }

        .slide-btn:disabled { opacity: 0.35; cursor: default; }

        .slides-close {
            position: absolute;
            right: 12px;
            top: 12px;
            background: transparent;
            border: none;
            color: #d4d4d4;
            font-size: 20px;
            cursor: pointer;
        }

        /* Inline slide view (replaces preview when active) */
        .slide-view {
            display: none;
            margin-top: 18px;
            background: #151515;
            padding: 18px;
            border-radius: 8px;
            color: #e6eef6;
        }

        .slide-view.open { display: block; }

        .slide-inline h1, .slide-inline h2, .slide-inline h3 { margin-top: 0; }

        .slide-controls-inline {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        /* Slides button when active */
        .slides-btn.active {
            background: linear-gradient(to right, #10b981, #06b6a4);
        }

        /* When slide-only mode is active, hide all non-slide UI and make the slide view full-screen */
        body.slide-inline-active #sidebar,
        body.slide-inline-active #toc-sidebar,
        body.slide-inline-active #toggle-md-files,
        body.slide-inline-active #toc-toggle,
        body.slide-inline-active .slides-btn,
        body.slide-inline-active #support-section,
        body.slide-inline-active #utterances-container,
        body.slide-inline-active footer,
        body.slide-inline-active .preview-container,
        body.slide-inline-active #file-list {
            display: none !important;
        }

        body.slide-inline-active #content {
            padding: 0 !important;
        }

        /* make the slide-view cover the whole viewport */
        body.slide-inline-active #slide-view {
            display: block !important;
            position: fixed !important;
            inset: 0 !important;
            z-index: 10000 !important;
            background: rgba(6,6,6,0.98) !important;
            padding: 48px !important;
            overflow: auto !important;
        }

        /* Scrollbar styling for slide view to match site */
        #slide-view::-webkit-scrollbar {
            width: 8px;
        }
        #slide-view::-webkit-scrollbar-track {
            background: #1e1e1e;
        }
        #slide-view::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        /* Firefox */
        #slide-view {
            scrollbar-width: thin;
            scrollbar-color: #444 #1e1e1e;
        }
        }

        body.slide-inline-active .slide-inline {
            max-width: 960px;
            margin: 0 auto;
            background: transparent;
            padding: 6px 12px;
        }

        body.slide-inline-active .slide-controls-inline {
            position: fixed;
            bottom: 20px;
            right: 20px;
            margin: 0;
            z-index: 10001;
        }

/* Base hamburger styles (work at all sizes) */
        .hamburger {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            width: 36px;
            height: 24px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            position: fixed;
            top: 10px;
            z-index: 3000;
        }

        .hamburger .bar {
            display: block;
            height: 3px;
            width: 100%;
            background: #ffffff;
            border-radius: 3px;
            transition: transform 0.25s ease, opacity 0.2s ease, background 0.2s ease;
        }

        .hamburger.open .bar:nth-child(1) { transform: translateY(8px) rotate(45deg); }
        .hamburger.open .bar:nth-child(2) { opacity: 0; transform: scaleX(0); }
        .hamburger.open .bar:nth-child(3) { transform: translateY(-8px) rotate(-45deg); }

        .hamburger:focus { outline: 2px solid rgba(106,17,203,0.12); border-radius: 6px; }
        .hamburger:hover .bar { background: linear-gradient(90deg, #6a11cb, #2575fc); }

        @media (max-width: 1200px) {
            #sidebar {
                display: none;
            }

            #sidebar.overlay {
                display: block;
            }

            #toc-sidebar {
                display: none;
            }

            #toc-sidebar.overlay {
                display: block;
            }

        /* Hamburger toggle buttons (polished) */
        .hamburger {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            width: 36px;
            height: 24px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            position: fixed;
            top: 10px;
            z-index: 3000;
        }

        #toggle-md-files { left: 10px; }
        #toc-toggle { right: 10px; }

        .hamburger .bar {
            display: block;
            height: 3px;
            width: 100%;
            background: #ffffff;
            border-radius: 3px;
            transition: transform 0.25s ease, opacity 0.2s ease;
        }

        .hamburger.open .bar:nth-child(1) { transform: translateY(8px) rotate(45deg); }
        .hamburger.open .bar:nth-child(2) { opacity: 0; transform: scaleX(0); }
        .hamburger.open .bar:nth-child(3) { transform: translateY(-8px) rotate(-45deg); }

        .hamburger:focus { outline: 2px solid rgba(106,17,203,0.12); border-radius: 6px; }
        .hamburger:hover .bar { background: linear-gradient(90deg, #6a11cb, #2575fc); }
             
        }
  /* Position adjustments for each button */
        #toggle-md-files {
            left: 10px;
        }

        #toc-toggle {
            right: 10px;
        }
        #support-section {
            padding: 10px;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            text-align: center;
        }

        #support-section h2 {
            color: #58a6ff;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        #support-section a {
            margin: 5px;
            text-decoration: none;
            color: #58a6ff;
            font-weight: bold;
            font-size: 0.9em;
        }

        #support-section a img {
            width: 180px;
            height: 45px;
            margin-bottom: 5px;
        }

        #support-section a:hover {
            color: #ffffff;
        }
@media (max-width: 500px) {
    body {
        flex-direction: column;
        align-items: center;
        padding: 10px;
    }

    #sidebar,
    #toc-sidebar {
        display: none;
    }

    #content {
        padding: 10px;
        width: 100%;
    }

    #preview {
        padding: 0px;
        font-size: 0.7em;
        line-height: 1.5;
        position: relative;
        border-radius: 8px;
        background-color: #1e1e1e;
        padding: 0px;
        box-shadow: 0 0px 0px rgba(0, 0, 0, 0.3);
        color: #d4d4d4;
        overflow: hidden;
    }
  

    .hamburger { display: block; position: fixed; top: 10px; z-index: 3000; }

    .hamburger .bar { width: 20px; height: 3px; margin: 4px 0; }

     /* Position adjustments for each button */
        #toggle-md-files {
            left: 10px;
        }

        #toc-toggle {
            right: 10px;
        }

    #support-section {
        padding: 8px;
        font-size: 0.8em;
    }

    h1 {
        font-size: 1.5em;
    }

    h2, h3, h4, h5, h6 {
        font-size: 1.2em;
    }

    pre {$1$2}

    code {$1$2}

      pre {
            background-color: #2D2D2D;
            color: #F8F8F2;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid #44475a;
            font-size: 0.8em;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }


    a {
        font-size: 1em;
    }

    img {
        max-width: 100%;
        height: auto;
    }

  

    #preview h1, #preview h2, #preview h3, #preview h4, #preview h5, #preview h6 {
        font-size: 1.2em;
        margin-bottom: 10px;
    }

    #preview p {
        margin-bottom: 10px;
    }

    /* File-specific action buttons (starter/final repos) */
    .file-action-buttons {
        margin: 10px 0 18px 0;
        display: flex;
        gap: 8px;
        align-items: center;
    }
    .file-action-button {
        background: linear-gradient(90deg,#6a11cb,#2575fc);
        color: #fff;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        text-decoration: none;
        font-weight: 600;
        display: inline-flex;
        gap: 8px;
        align-items: center;
    }
    .file-action-button.secondary {
        background: linear-gradient(90deg,#10b981,#06b6a4);
    }
    .file-action-button[aria-hidden="true"] { display: none; }

    .file-action-download {
        background: transparent;
        border: 1px solid rgba(255,255,255,0.06);
        color: #d4d4d4;
        padding: 6px 8px;
        border-radius: 6px;
        font-size: 0.9em;
        cursor: pointer;
    }
    .file-action-download:hover { background: rgba(255,255,255,0.03); }

    #preview ul {
        padding-left: 20px;
        margin-bottom: 10px;
    }

    #preview li {
        margin-bottom: 5px;
    }
}
/* Compact download row */
.download-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0 18px 0;
}

.download-row span {
    font-weight: 600;
    color: #cfd6e0;
}

.download-btn {
    background: linear-gradient(90deg,#6a11cb,#2575fc);
    color: #fff;
    border: none;
    padding: 8px 14px;
    border-radius: 6px;
    font-weight: 600;
    cursor: pointer;
}

.download-btn.final {
    background: linear-gradient(90deg,#10b981,#06b6a4);
}

.download-btn:hover {
    transform: translateY(-2px);
}

.download-row {
    display: flex;
    justify-content: flex-end; /* âœ… moves buttons to right */
    align-items: center;
    gap: 10px;
    margin: 10px 0 18px;
}
.download-row {
    display: flex;
    justify-content: flex-end;
    margin: 12px 0 20px;
}
.download-button-group {
    display: flex;
    gap: 12px;
    padding: 14px;
    border-radius: 14px;
    background: rgba(255,255,255,0.04);
    backdrop-filter: blur(8px);
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
}
.download-btn {
    min-width: 140px;
    padding: 12px 18px;
    border-radius: 10px;
    border: none;
    font-weight: 700;
    cursor: pointer;
    color: #6a11cb;
    background: #ffffff;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.download-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 14px rgba(0,0,0,0.25);
}

.download-btn.final {
    background: #1f1f1f;
    color: #ffffff;
}
.download-button-group:empty {
    display: none;
}

.page-header-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 12px; /* controls space below header */
}

.page-header-bar h1 {
    margin: 0;            /* ðŸ”¥ removes huge default h1 gap */
    line-height: 1.2;
}

.file-action-buttons {
    margin: 0;            /* ðŸ”¥ prevents vertical push */
    display: flex;
    align-items: center;
}
.lesson-header {
    display: flex;
    align-items: center;
    justify-content: space-between;

    padding: 18px 22px;
    margin-bottom: 16px;

    border-radius: 16px;
    background: linear-gradient(
        180deg,
        rgba(255,255,255,0.06),
        rgba(255,255,255,0.02)
    );

    box-shadow:
        0 10px 30px rgba(0,0,0,0.35),
        inset 0 1px 0 rgba(255,255,255,0.06);
}

.lesson-header h1 {
    margin: 0;
    font-size: 1.8rem;
    font-weight: 800;
    line-height: 1.2;

    background: linear-gradient(90deg, #9b5cff, #c77dff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.file-action-buttons {
    display: flex;
    gap: 12px;
}
.download-btn {
    padding: 10px 18px;
    border-radius: 12px;
    border: none;

    font-weight: 700;
    font-size: 0.95rem;

    cursor: pointer;
    background: #ffffff;
    color: #6a11cb;

    transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.download-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.3);
}

.download-btn.final {
    background: #1f1f1f;
    color: #ffffff;
}
@media (max-width: 700px) {
    .lesson-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 14px;
    }

    .file-action-buttons {
        align-self: flex-end;
    }
}

    </style>
</head>
<body>
    <button id="toggle-md-files" class="hamburger" aria-label="Toggle files" aria-expanded="false" title="Toggle files">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
    </button>

    <div id="sidebar">
        <h3>Guide</h3>
        <div id="file-list">
            <!-- JavaScript will populate this -->
        </div>
    </div>

    <div id="content">
<div class="lesson-header">
    <h1 id="page-header"></h1>

    <div id="page-actions" class="file-action-buttons" aria-hidden="true">
        <!-- buttons injected by JS -->
    </div>
</div>

        <div class="preview-container">
            <div id="preview">
                <!-- Your markdown content goes here -->
            </div>
             <!-- Utterances Comment Section -->
            <div id="utterances-container"></div>
            <!-- End of Utterances -->
        </div>

        <!-- Inline Slide View (hidden by default) -->
        <div id="slide-view" class="slide-view" style="display:none;">
            <div id="slide-inline" class="slide-inline"></div>
            <div class="slide-controls-inline">
                <button id="slide-prev-inline" class="slide-btn">Prev</button>
                <button id="slide-next-inline" class="slide-btn">Next</button>
                <button id="slide-close-inline" class="slide-btn">Exit</button>
            </div>
        </div>
       
    </div>

      <button id="toc-toggle" class="hamburger" aria-label="Toggle table of contents" aria-expanded="false" title="Toggle table of contents">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
    </button>

    <button id="slides-toggle" class="slides-btn" title="View as slides">View as slides</button>

    <div id="toc-sidebar">
        <h3>Table of Contents</h3>
        <div id="toc-list"></div>
        <div id="support-section">
            <h2>Support My Work</h2>
            <a href="https://www.buymeacoffee.com/adityamali98" target="_blank"><img src="https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=&slug=adityamali98&button_colour=FFDD00&font_colour=000000&font_family=Cookie&outline_colour=000000&coffee_colour=ffffff" /></a>
            <a href="https://www.youtube.com/@GFX-Programming" target="_blank">
                <img src="https://upload.wikimedia.org/wikipedia/commons/4/42/YouTube_icon_%282013-2017%29.png" alt="YouTube" style="width: 24px; height: 24px; vertical-align: middle; margin-right: 8px;"> GFX Programming
            </a>
            <div style="text-align: center; padding-top: 20px; color: #d4d4d4; font-size: 0.9em;">
                Explained by
            </div>
            <a href="https://www.linkedin.com/in/aditya-mali-477a01156/" style="color: #ffdd00; font-size: 0.9em;">
                Aditya Mali
            </a>
        </div>
    </div>

    <div id="slides-overlay" class="slides-overlay" aria-hidden="true">
        <div class="slides-inner">
            <button id="slides-close" class="slides-close" aria-label="Close">Ã—</button>
            <div id="slide-content" class="slide-content"></div>
            <div class="slide-controls">
                <button id="slide-prev" class="slide-btn">Prev</button>
                <button id="slide-next" class="slide-btn">Next</button>
            </div>
        </div>
    </div>

    <script>
        let appConfig = {};
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                if (!response.ok) {
                    throw new Error('Failed to load config.json');
                }
                const config = await response.json();
                applyConfig(config);
                if (config.default_markdown) {
                    const resolvedDefault = (function(cfg, name){
                        if (!name) return null;
                        if (name.includes('/') || name.startsWith('./') || name.startsWith('../')) return name;
                        for (const group of (cfg.markdownFiles || [])) {
                            for (const f of (group.files || [])) {
                                if (f.fileName === name || f.displayName === name) {
                                    return (group.path ? (group.path.endsWith('/') ? group.path.slice(0, -1) : group.path) + '/' + f.fileName : f.fileName);
                                }
                            }
                        }
                        return name;
                    })(config, config.default_markdown);
                    if (resolvedDefault) {
                        loadMarkdownFile(resolvedDefault);
                    }
                    // highlight after load (default) will be handled by loadMarkdownFile
                }
            } catch (error) {
                console.error('Error loading config:', error);
            }
        }

        function applyConfig(config) {
            appConfig = config;
            if (appConfig.mediaPath) {
                appConfig.mediaPath = appConfig.mediaPath.replace(/\/+$/, '');
            }
            document.title = config.pageTitle;
            document.getElementById('page-header').textContent = config.pageHeader;

            loadMarkdownFiles(config.markdownFiles);

            const utterancesContainer = document.getElementById('utterances-container');
            // keep utterances container empty for now; comments will be loaded per-file
            utterancesContainer.innerHTML = '';
            // store utterances config in appConfig so it can be used when files are opened
            if (!appConfig.utterances && config.utterances) appConfig.utterances = config.utterances;
        }

        function resolveFilePath(groupPath, fileName) {
            if (!groupPath) return fileName;
            const gp = groupPath.endsWith('/') ? groupPath.slice(0, -1) : groupPath;
            const fn = fileName.startsWith('/') ? fileName.slice(1) : fileName;
            return gp + '/' + fn;
        }

        function buildFileListItem(file, groupPath = '') {
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = '#';
            a.textContent = file.displayName;
            const resolved = resolveFilePath(groupPath, file.fileName);
            a.dataset.file = resolved;
            a.className = 'guide-file-link';
            a.addEventListener('click', (e) => {
                e.preventDefault();
                loadMarkdownFile(resolved);
            });
            li.appendChild(a);
            return li;
        }

        function highlightActiveFile(fileName) {
            // remove previous
            document.querySelectorAll('.guide-file-link.active').forEach(el => el.classList.remove('active'));
            const el = document.querySelector(`.guide-file-link[data-file="${fileName}"]`);
            if (el) {
                el.classList.add('active');
                // ensure parent group is open (do not apply highlight class to the group header)
                const groupContents = el.closest('.guide-group-contents');
                if (groupContents && !groupContents.classList.contains('open')) {
                    const header = groupContents.previousElementSibling;
                    const caret = header && header.querySelector('.caret');
                    groupContents.classList.add('open');
                    if (caret) caret.textContent = 'â–¾';
                    // do NOT persist this automatic open in localStorage (only user toggles persist)
                }
            }
        }

        function getDisplayNameForPath(filePath) {
            if (!filePath) return '';
            const parts = filePath.split('/');
            const fileOnly = parts[parts.length - 1];
            // try to find a matching file entry in the config so we can use its displayName
            for (const group of (appConfig.markdownFiles || [])) {
                for (const f of (group.files || [])) {
                    const groupPath = group.path ? (group.path.endsWith('/') ? group.path.slice(0, -1) : group.path) : '';
                    const resolved = groupPath ? (groupPath + '/' + f.fileName) : f.fileName;
                    if (f.fileName === fileOnly || resolved === filePath || f.displayName === filePath) {
                        return f.displayName || f.fileName;
                    }
                }
            }
            return fileOnly;
        }

        function setCurrentPageHeader(filePath) {
            const name = getDisplayNameForPath(filePath) || (appConfig && appConfig.pageHeader) || '';
            const headerEl = document.getElementById('page-header');
            if (headerEl) headerEl.textContent = name;
            // also update document title to include the app page title
            if (appConfig && appConfig.pageTitle) {
                document.title = (name ? name + ' - ' : '') + appConfig.pageTitle;
            }
            // update file action buttons (starter/final repos)
            updateFileActionButtons(filePath);
        }

        // Load utterances for a specific file so comments are scoped per-file
        function loadUtterancesForFile(filePath) {
            const container = document.getElementById('utterances-container');
            container.innerHTML = '';
            if (!appConfig.utterances) return;



            // Use the URL (including hash) as the issue-term so utterances will associate a unique thread per file
            // We set the hash to a stable encoded form of the file path.
            const encoded = encodeURIComponent(filePath || '');
            const base = window.location.origin + window.location.pathname + window.location.search;
            const newUrl = base + '#file=' + encoded;
            history.replaceState({}, '', newUrl);

            const script = document.createElement('script');
            script.src = 'https://utteranc.es/client.js';
            script.setAttribute('repo', appConfig.utterances.repo);
            // use the page title as the issue-term so each file (which sets a unique title) has its own thread
            script.setAttribute('issue-term', 'title');
            // add a label with the file path for easier filtering in GitHub issues
            script.setAttribute('label', encodeURIComponent(filePath || ''));
            if (appConfig.utterances.theme) script.setAttribute('theme', appConfig.utterances.theme);
            script.setAttribute('crossorigin', 'anonymous');
            script.async = true;
            container.appendChild(script);
        }

        // Find file config by path (group + file entry)
        function getFileConfigForPath(filePath) {
            if (!filePath || !appConfig.markdownFiles) return null;
            for (const group of (appConfig.markdownFiles || [])) {
                const gp = group.path ? (group.path.endsWith('/') ? group.path.slice(0, -1) : group.path) : '';
                for (const f of (group.files || [])) {
                    const resolved = gp ? (gp + '/' + f.fileName) : f.fileName;
                    if (resolved === filePath || f.fileName === filePath) {
                        return Object.assign({ _group: group.group, _groupPath: gp }, f);
                    }
                }
            }
            return null;
        }

        function updateFileActionButtons(filePath) {
            const container = document.getElementById('page-actions');
            if (!container) return;
            container.innerHTML = '';
            const cfg = getFileConfigForPath(filePath);
            if (!cfg) {
                container.setAttribute('aria-hidden', 'true');
                return;
            }
            const starter = cfg.starterRepo || cfg.starter || '';
            const finalc = cfg.finalRepo || cfg.final || '';

            function parseGitHubRepo(url) {
                if (!url) return null;
                try {
                    const u = new URL(url, window.location.href);
                    if (!u.hostname.includes('github.com')) return null;
                    const parts = u.pathname.split('/').filter(Boolean);
                    if (parts.length < 2) return null;
                    const owner = parts[0];
                    const repo = parts[1].replace(/\.git$/, '');
                    let branch = null;
                    const treeIndex = parts.indexOf('tree');
                    if (treeIndex >= 0 && parts.length > treeIndex + 1) branch = parts[treeIndex + 1];
                    return { isGitHub: true, owner, repo, branch };
                } catch (e) { return null; }
            }

            async function getDefaultBranch(owner, repo) {
                try {
                    const r = await fetch(`https://api.github.com/repos/${owner}/${repo}`);
                    if (!r.ok) return null;
                    const j = await r.json();
                    return j && j.default_branch ? j.default_branch : null;
                } catch (e) { return null; }
            }

            async function downloadRepoZip(url) {
                const info = parseGitHubRepo(url);
                if (!info) { window.open(url, '_blank'); return; }
                let branch = info.branch || await getDefaultBranch(info.owner, info.repo) || 'main';
                const zipUrl = `https://github.com/${info.owner}/${info.repo}/archive/refs/heads/${branch}.zip`;
                window.open(zipUrl, '_blank');
            }

            function addActionLink(href, label, opts = {}) {
                const el = document.createElement('a');
                el.className = 'file-action-button' + (opts.secondary ? ' secondary' : '');
                el.href = href;
                el.target = '_blank';
                el.rel = 'noopener';
                el.textContent = label;
                if (opts.title) el.title = opts.title;
                container.appendChild(el);
                return el;
            }

            function addDownloadButton(repoUrl) {
                const info = parseGitHubRepo(repoUrl);
                const btn = document.createElement('button');
                btn.className = 'file-action-download';
                btn.type = 'button';
                btn.title = 'Download ZIP';
                btn.textContent = 'Download ZIP';
                btn.addEventListener('click', (e) => { e.preventDefault(); downloadRepoZip(repoUrl); });
                container.appendChild(btn);
                return btn;
            }

         // ---------- NEW UI ----------
       // ---------- NEW UI ----------
const row = document.createElement('div');
row.className = 'download-row';

const buttonGroup = document.createElement('div');
buttonGroup.className = 'download-button-group';

if (starter) {
    const btnStarter = document.createElement('button');
    btnStarter.className = 'download-btn';
    btnStarter.textContent = 'Starter Code';
    btnStarter.addEventListener('click', (e) => {
        e.preventDefault();
        downloadRepoZip(starter);
    });
    buttonGroup.appendChild(btnStarter);
}

if (finalc) {
    const btnFinal = document.createElement('button');
    btnFinal.className = 'download-btn final';
    btnFinal.textContent = 'Final Code';
    btnFinal.addEventListener('click', (e) => {
        e.preventDefault();
        downloadRepoZip(finalc);
    });
    buttonGroup.appendChild(btnFinal);
}

row.appendChild(buttonGroup);
container.appendChild(row);
container.setAttribute('aria-hidden', 'false');
        }

        function getSavedGroups() {
            try {
                return JSON.parse(localStorage.getItem('guideGroups') || '{}');
            } catch (e) { return {}; }
        }
        function saveGroups(obj) {
            try { localStorage.setItem('guideGroups', JSON.stringify(obj)); } catch (e) {}
        }

        function loadMarkdownFiles(markdownFiles) {
            const fileListElement = document.getElementById('file-list');
            fileListElement.innerHTML = '';

            const saved = getSavedGroups();

            // Support grouped format: [{ group: 'Basics', files: [...] }, ...]
            if (markdownFiles.length && markdownFiles[0].group && Array.isArray(markdownFiles[0].files)) {
                markdownFiles.forEach(group => {
                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'guide-group-header';

                    const caret = document.createElement('span');
                    caret.className = 'caret';
                    caret.textContent = 'â–¸';
                    groupHeader.appendChild(caret);

                    const title = document.createElement('span');
                    title.textContent = group.group;
                    groupHeader.appendChild(title);

                    const groupContents = document.createElement('div');
                    groupContents.className = 'guide-group-contents';
                    const ul = document.createElement('ul');

                    (group.files || []).forEach(file => {
                        ul.appendChild(buildFileListItem(file, group.path || ''));
                    });

                    groupContents.appendChild(ul);

                    // restore saved state
                    const isOpenSaved = !!saved[group.group];
                    if (isOpenSaved) {
                        groupContents.classList.add('open');
                        groupHeader.classList.add('open');
                        caret.textContent = 'â–¾';
                    }

                    // toggle expansion when header clicked
                    groupHeader.addEventListener('click', () => {
                        const isOpen = groupContents.classList.toggle('open');
                        groupHeader.classList.toggle('open', isOpen);
                        caret.textContent = isOpen ? 'â–¾' : 'â–¸';
                        // persist
                        const obj = getSavedGroups();
                        obj[group.group] = isOpen;
                        saveGroups(obj);
                    });

                    fileListElement.appendChild(groupHeader);
                    fileListElement.appendChild(groupContents);
                });
                return;
            }

            // fallback: flat list of files (no subtopics)
            const ul = document.createElement('ul');
            markdownFiles.forEach(file => {
                ul.appendChild(buildFileListItem(file));
            });
            fileListElement.appendChild(ul);
        }

        async function loadMarkdownFile(fileName, anchorText = null) {
            try {
                const response = await fetch(fileName);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const text = await response.text();
                renderMarkdown(text, fileName);
                // highlight active file in Guide
                highlightActiveFile(fileName);
                // update the page header/title to reflect the current file
                setCurrentPageHeader(fileName);
                // load utterances comments scoped to this file (so each file has its own comment thread)
                loadUtterancesForFile(fileName);

                // after render, if an anchor (heading text) was provided, scroll to it
                if (anchorText) {
                    // small timeout to ensure ids are applied
                    setTimeout(() => {
                        const headers = Array.from(document.getElementById('preview').querySelectorAll('h1, h2, h3, h4, h5, h6'));
                        const target = headers.find(h => h.textContent.trim() === anchorText.trim());
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth' });
                            // note: no visual highlight on the content heading â€” only the file name in the Guide is highlighted
                        }
                    }, 40);
                }
            } catch (error) {
                console.error('Error loading markdown file:', error);
            }
        }

        function renderMarkdown(markdownText, currentFile = '') {
            // rewrite Obsidian-style embeds (![[file]]) and resolve image paths using appConfig.mediaPath
            function rewriteImagePaths(mdText) {
                let text = mdText;
                const mediaRoot = (appConfig && appConfig.mediaPath) ? appConfig.mediaPath.replace(/\/+$/, '') : null;

                // Obsidian embed syntax: ![[File name.png]] or ![[Media/File name.png]]
                text = text.replace(/!\[\[([^\]]+)\]\]/g, (m, inner) => {
                    let path = inner.split('|')[0].trim();
                    // remove leading slashes
                    path = path.replace(/^\/+/, '');
                    const src = mediaRoot ? (mediaRoot + '/' + encodeURI(path)) : encodeURI(path);
                    return '![](' + src + ')';
                });

                // Standard markdown images: ![alt](src)
                text = text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (m, alt, src) => {
                    src = src.trim();
                    if (src.startsWith('<') && src.endsWith('>')) src = src.slice(1, -1);
                    // leave absolute URLs, data URLs, and rooted/relative paths alone
                    if (/^(?:https?:|data:|\/|\.\.|\.\/)/i.test(src) || src.includes(':')) {
                        return '![' + alt + '](' + src + ')';
                    }
                    // otherwise, prefix with mediaRoot if available
                    if (mediaRoot) {
                        const newSrc = mediaRoot + '/' + src;
                        return '![' + alt + '](' + encodeURI(newSrc) + ')';
                    }
                    return m;
                });

                return text;
            }

            function rewriteYouTubeEmbeds(mdText) {
                let text = mdText;
                const originParam = encodeURIComponent(window.location.origin || window.location.href);
                function extractId(url) {
                    try {
                        const u = new URL(url);
                        if (u.hostname.includes('youtu.be')) {
                            return u.pathname.slice(1).split(/[?#]/)[0];
                        }
                        if (u.hostname.includes('youtube.com')) {
                            return u.searchParams.get('v');
                        }
                    } catch (e) {
                        const m = url.match(/(?:v=|youtu\.be\/)([A-Za-z0-9_-]{11})/);
                        return m && m[1];
                    }
                    const m = url.match(/(?:v=|youtu\.be\/)([A-Za-z0-9_-]{11})/);
                    return m && m[1];
                }

                // URL on its own line (plain or wrapped in <>): embed
                text = text.replace(/^(\s*<?(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)[^\s<>]+)>?\s*)$/gm, (m, whole, url) => {
                    const cleaned = (url || whole).trim().replace(/^<|>$/g, '');
                    const id = extractId(cleaned);
                    if (!id) return m;
                    return `<div class="video-embed" data-yid="${id}"><iframe loading="lazy" src="https://www.youtube-nocookie.com/embed/${id}?rel=0&origin=${originParam}" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen title="YouTube video player"></iframe><div class="video-fallback">Can't play? <a href="https://www.youtube.com/watch?v=${id}" target="_blank" rel="noopener">Open on YouTube</a></div></div>`;
                });

                // markdown link on its own line: [text](youtube-url)
                text = text.replace(/^(\s*\[[^\]]+\]\(\s*(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)[^\s)]+)\s*\)\s*)$/gm, (m, url) => {
                    const id = extractId(url);
                    if (!id) return m;
                    return `<div class="video-embed" data-yid="${id}"><iframe loading="lazy" src="https://www.youtube-nocookie.com/embed/${id}?rel=0&origin=${originParam}" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen title="YouTube video player"></iframe><div class="video-fallback">Can't play? <a href="https://www.youtube.com/watch?v=${id}" target="_blank" rel="noopener">Open on YouTube</a></div></div>`;
                });

                // markdown link where the URL is in the link text and the parentheses are empty: [https://...]()
                text = text.replace(/^\s*\[(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)[^\]]+)\]\(\s*\)\s*$/gm, (m, url) => {
                    const id = extractId(url);
                    if (!id) return m;
                    return `<div class="video-embed" data-yid="${id}"><iframe loading="lazy" src="https://www.youtube-nocookie.com/embed/${id}?rel=0&origin=${originParam}" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen title="YouTube video player"></iframe><div class="video-fallback">Can't play? <a href="https://www.youtube.com/watch?v=${id}" target="_blank" rel="noopener">Open on YouTube</a></div></div>`;
                });

                // angle-bracketed URL anywhere
                text = text.replace(/<https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)[^>]+>/g, (m) => {
                    const url = m.slice(1, -1);
                    const id = extractId(url);
                    if (!id) return m;
                    return `<div class="video-embed" data-yid="${id}"><iframe loading="lazy" src="https://www.youtube-nocookie.com/embed/${id}?rel=0&origin=${originParam}" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen title="YouTube video player"></iframe><div class="video-fallback">Can't play? <a href="https://www.youtube.com/watch?v=${id}" target="_blank" rel="noopener">Open on YouTube</a></div></div>`;
                });

                return text;
            }

            const md = window.markdownit({ html: true,
                highlight: function (str, lang) {
                    if (lang) {
                        try {
                            return '<pre><code class="language-' + lang + '">' +
                                hljs.highlight(str, { language: lang }).value +
                                '</code></pre>';
                        } catch (__) {}
                    }
                    return '<pre><code>' + md.utils.escapeHtml(str) + '</code></pre>';
                }
            });

            const previewArea = document.getElementById('preview');
            let processed = rewriteImagePaths(markdownText);
            processed = rewriteYouTubeEmbeds(processed);
            previewArea.innerHTML = md.render(processed);
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            generateTOC();
            buildSlides();
            attachYouTubePlayers();
        }

        function slugify(text) {
            return text.toLowerCase().trim()
                .replace(/[^\w\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-');
        }

        /* YouTube IFrame API-based fallback handler */
        const __ytPending = [];
        let __ytApiLoading = false;
        function ensureYouTubeApiLoaded() {
            if (window.YT && window.YT.Player) {
                return Promise.resolve();
            }
            if (__ytApiLoading) return new Promise((res) => { const i = setInterval(()=>{ if (window.YT && window.YT.Player) { clearInterval(i); res(); } }, 50); });
            __ytApiLoading = true;
            return new Promise((resolve) => {
                const tag = document.createElement('script');
                tag.src = 'https://www.youtube.com/iframe_api';
                const firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
                window.onYouTubeIframeAPIReady = () => { resolve(); };
                // safety: also poll in case onYouTube... not fired
                const poll = setInterval(() => { if (window.YT && window.YT.Player) { clearInterval(poll); resolve(); } }, 100);
            });
        }

        function attachYouTubePlayers() {
            const containers = Array.from(document.querySelectorAll('.video-embed')).filter(el => el.dataset.yid && !el.dataset.ytInit);
            if (containers.length === 0) return;
            containers.forEach(el => el.dataset.ytInit = '1');
            ensureYouTubeApiLoaded().then(() => {
                containers.forEach((el, idx) => {
                    tryInitPlayer(el);
                });
            }).catch(() => {
                // leave fallback link visible if API load fails
                containers.forEach(el => showFallback(el));
            });
        }

        function tryInitPlayer(container) {
            const yid = container.dataset.yid;
            if (!yid) return showFallback(container);
            // remove any pre-existing iframe placed by renderer to let API create a managed player
            const existingIframe = container.querySelector('iframe');
            if (existingIframe) existingIframe.remove();
            // create a div placeholder
            const pid = `yt-player-${yid}-${Math.random().toString(36).slice(2,9)}`;
            const placeholder = document.createElement('div');
            placeholder.id = pid;
            placeholder.style.width = '100%';
            placeholder.style.height = '100%';
            // add placeholder at beginning
            container.insertBefore(placeholder, container.firstChild);

            // create the player using the nocookie host to keep privacy mode
            try {
                /* eslint-disable no-undef */
                const player = new YT.Player(pid, {
                    videoId: yid,
                    host: 'https://www.youtube-nocookie.com',
                    playerVars: {
                        rel: 0,
                        modestbranding: 1,
                        origin: window.location.origin || window.location.href
                    },
                    events: {
                        onError: (e) => {
                            // error codes 100, 101, 150 usually mean unavailable or embedding disabled
                            showFallback(container, yid);
                        }
                    }
                });
                /* eslint-enable no-undef */
                // leave the fallback link hidden until error occurs
                const fb = container.querySelector('.video-fallback');
                if (fb) fb.style.display = 'none';
            } catch (e) {
                showFallback(container, yid);
            }
        }

        function showFallback(container, yid) {
            container.classList.add('embed-failed');
            const id = yid || container.dataset.yid;
            container.innerHTML = `<div class="video-fallback">Can't play? <a href="https://www.youtube.com/watch?v=${id}" target="_blank" rel="noopener">Open on YouTube</a></div>`;
        }

        function extractHeadingsFromMarkdown(mdText) {
            const lines = mdText.split(/\r?\n/);
            const headings = [];
            lines.forEach(line => {
                const m = line.match(/^(#{1,6})\s+(.*)$/);
                if (m) {
                    headings.push({ level: m[1].length, text: m[2].trim() });
                }
            });
            return headings;
        }

        function buildNestedListFromHeadings(headings, file) {
            const rootUl = document.createElement('ul');
            const stack = [{ level: 0, ul: rootUl }];
            headings.forEach(h => {
                const level = Math.max(1, Math.min(6, h.level));
                if (level > stack[stack.length - 1].level) {
                    for (let l = stack[stack.length - 1].level + 1; l <= level; l++) {
                        const parentUl = stack[stack.length - 1].ul;
                        let parentLi = parentUl.lastElementChild;
                        if (!parentLi) {
                            parentLi = document.createElement('li');
                            parentUl.appendChild(parentLi);
                        }
                        const newUl = document.createElement('ul');
                        parentLi.appendChild(newUl);
                        stack.push({ level: l, ul: newUl });
                    }
                } else {
                    while (level < stack[stack.length - 1].level) stack.pop();
                }

                const currentUl = stack[stack.length - 1].ul;
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = h.text;
                a.addEventListener('click', (e) => {
                    e.preventDefault();
                    // load the file and scroll to the heading text
                    loadMarkdownFile(file.fileName, h.text);
                    // expand the file node in the sidebar
                    const fileNode = a.closest('.guide-file');
                    if (fileNode) {
                        const contents = fileNode.querySelector('.guide-file-contents');
                        const caret = fileNode.querySelector('.caret');
                        if (contents && caret) {
                            contents.classList.add('open');
                            caret.textContent = 'â–¾';
                        }
                    }
                });
                li.appendChild(a);
                currentUl.appendChild(li);
            });
            return rootUl;
        }

        // Completed state helpers (localStorage)
        function getCompletedIds() {
            try {
                const raw = localStorage.getItem('tocCompleted') || '[]';
                return new Set(JSON.parse(raw));
            } catch (e) {
                return new Set();
            }
        }

        function saveCompletedIds(set) {
            try {
                localStorage.setItem('tocCompleted', JSON.stringify(Array.from(set)));
            } catch (e) {}
        }

        function generateTOC() {
            const tocListElement = document.getElementById('toc-list');
            tocListElement.innerHTML = '';
            const headers = Array.from(document.getElementById('preview').querySelectorAll('h1, h2, h3, h4, h5, h6'));
            if (headers.length === 0) return;

            const completed = getCompletedIds();

            const rootUl = document.createElement('ul');
            rootUl.className = 'toc-root';
            const stack = [{ level: 0, ul: rootUl }];

            headers.forEach(header => {
                // ensure header has id
                if (!header.id) {
                    let id = slugify(header.textContent);
                    let uniqueId = id;
                    let idx = 1;
                    while (document.getElementById(uniqueId)) {
                        uniqueId = `${id}-${idx++}`;
                    }
                    header.id = uniqueId;
                }

                const level = parseInt(header.tagName.substring(1), 10);

                // Adjust stack to the correct level
                if (level > stack[stack.length - 1].level) {
                    for (let l = stack[stack.length - 1].level + 1; l <= level; l++) {
                        const parentUl = stack[stack.length - 1].ul;
                        let parentLi = parentUl.lastElementChild;
                        if (!parentLi) {
                            parentLi = document.createElement('li');
                            parentUl.appendChild(parentLi);
                        }
                        const newUl = document.createElement('ul');
                        parentLi.appendChild(newUl);
                        stack.push({ level: l, ul: newUl });
                    }
                } else {
                    while (level < stack[stack.length - 1].level) {
                        stack.pop();
                    }
                }

                const currentUl = stack[stack.length - 1].ul;
                const li = document.createElement('li');

                // toggle button for completed state
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'toc-complete-toggle';
                toggleBtn.title = 'Mark completed';
                toggleBtn.addEventListener('click', (ev) => {
                    ev.preventDefault();
                    ev.stopPropagation();
                    const id = header.id;
                    if (completed.has(id)) {
                        completed.delete(id);
                        toggleBtn.classList.remove('checked');
                        li.classList.remove('completed');
                    } else {
                        completed.add(id);
                        toggleBtn.classList.add('checked');
                        li.classList.add('completed');
                    }
                    saveCompletedIds(completed);
                });

                const link = document.createElement('a');
                link.href = `#${header.id}`;
                link.textContent = header.textContent;
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    header.scrollIntoView({ behavior: 'smooth' });
                    // mark the clicked item as active
                    tocListElement.querySelectorAll('li').forEach(item => item.classList.remove('active'));
                    li.classList.add('active');
                });
                link.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    enterInlineSlidesAtHeaderId(header.id);
                });

                // set initial completed state
                if (completed.has(header.id)) {
                    toggleBtn.classList.add('checked');
                    li.classList.add('completed');
                }

                li.appendChild(toggleBtn);
                li.appendChild(link);
                currentUl.appendChild(li);
            });

            // mark items with children for L-branch visuals
            rootUl.querySelectorAll('li').forEach(item => {
                if (item.querySelector('ul')) item.classList.add('has-children');
            });

            tocListElement.appendChild(rootUl);
        }

        // --- Slide mode functionality ---
        let slides = [];
        let currentSlide = 0;

        function buildSlides() {
            slides = [];
            const preview = document.getElementById('preview');
            if (!preview) return;
            const headers = Array.from(preview.querySelectorAll('h1, h2, h3, h4, h5, h6'));
            if (headers.length === 0) {
                slides = [{ id: null, html: preview.innerHTML }];
                return;
            }
            headers.forEach(header => {
                let html = header.outerHTML;
                let el = header.nextElementSibling;
                while (el && !(el.tagName && /^H[1-6]$/.test(el.tagName))) {
                    html += el.outerHTML;
                    el = el.nextElementSibling;
                }
                slides.push({ id: header.id || null, html });
            });
        }

        function openSlides(startIndex = 0) {
            const overlay = document.getElementById('slides-overlay');
            if (!overlay) return;
            currentSlide = Math.max(0, Math.min(startIndex, slides.length - 1));
            overlay.classList.add('open');
            overlay.setAttribute('aria-hidden', 'false');
            updateSlide();
        }

        function closeSlides() {
            const overlay = document.getElementById('slides-overlay');
            if (!overlay) return;
            overlay.classList.remove('open');
            overlay.setAttribute('aria-hidden', 'true');
        }

        function updateSlide() {
            const content = document.getElementById('slide-content');
            if (!content) return;
            content.innerHTML = slides[currentSlide] ? slides[currentSlide].html : '';
            const prevBtn = document.getElementById('slide-prev');
            const nextBtn = document.getElementById('slide-next');
            if (prevBtn) prevBtn.disabled = currentSlide === 0;
            if (nextBtn) nextBtn.disabled = currentSlide === slides.length - 1;
        }

        function nextSlide() {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                updateSlide();
            }
        }

        function prevSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                updateSlide();
            }
        }

        function openSlidesAtHeaderId(id) {
            const idx = slides.findIndex(s => s.id === id);
            if (idx >= 0) openSlides(idx);
        }

        // UI hooks
        document.addEventListener('click', (e) => {
            if (e.target && e.target.id === 'slides-toggle') {
                e.preventDefault();
                // toggle inline slide view
                const isInline = document.body.classList.contains('slide-inline-active');
                if (isInline) exitInlineSlides();
                else enterInlineSlides(0);
            }
        });

        const nextBtnInit = document.getElementById('slide-next');
        if (nextBtnInit) nextBtnInit.addEventListener('click', nextSlide);
        const prevBtnInit = document.getElementById('slide-prev');
        if (prevBtnInit) prevBtnInit.addEventListener('click', prevSlide);
        const closeBtnInit = document.getElementById('slides-close');
        if (closeBtnInit) closeBtnInit.addEventListener('click', closeSlides);

        // keyboard navigation for overlay and inline slide view
        document.addEventListener('keydown', (e) => {
            const overlay = document.getElementById('slides-overlay');
            const inlineActive = document.body.classList.contains('slide-inline-active');
            if ((overlay && overlay.classList.contains('open'))) {
                if (e.key === 'ArrowRight') nextSlide();
                else if (e.key === 'ArrowLeft') prevSlide();
                else if (e.key === 'Escape') closeSlides();
                return;
            }
            if (inlineActive) {
                if (e.key === 'ArrowRight') nextSlideInline();
                else if (e.key === 'ArrowLeft') prevSlideInline();
                else if (e.key === 'Escape') exitInlineSlides();
            }
        });

        // Inline slide controls
        function enterInlineSlides(startIndex = 0) {
            buildSlides();
            currentSlide = Math.max(0, Math.min(startIndex, slides.length - 1));
            // activate slide-only UI
            document.body.classList.add('slide-inline-active');
            // prevent background scroll
            document.documentElement.style.overflow = 'hidden';
            document.body.style.overflow = 'hidden';
            // hide preview container (kept for restoration) and other UI via CSS rules
            document.getElementById('preview').closest('.preview-container').style.display = 'none';
            const sv = document.getElementById('slide-view');
            sv.classList.add('open');
            sv.style.display = 'block';
            document.getElementById('slides-toggle').classList.add('active');
            document.getElementById('slides-toggle').textContent = 'View as document';
            updateSlideInline();
        }

        function exitInlineSlides() {
            document.body.classList.remove('slide-inline-active');
            // restore scrolling
            document.documentElement.style.overflow = '';
            document.body.style.overflow = '';
            const sv = document.getElementById('slide-view');
            sv.classList.remove('open');
            sv.style.display = 'none';
            document.getElementById('preview').closest('.preview-container').style.display = '';
            document.getElementById('slides-toggle').classList.remove('active');
            document.getElementById('slides-toggle').textContent = 'View as slides';
        }

        function updateSlideInline() {
            const content = document.getElementById('slide-inline');
            if (!content) return;
            content.innerHTML = slides[currentSlide] ? slides[currentSlide].html : '';
            const prevBtn = document.getElementById('slide-prev-inline');
            const nextBtn = document.getElementById('slide-next-inline');
            if (prevBtn) prevBtn.disabled = currentSlide === 0;
            if (nextBtn) nextBtn.disabled = currentSlide === slides.length - 1;
            // ensure syntax highlighting inside slide
            content.querySelectorAll('pre code').forEach((block) => hljs.highlightElement(block));
        }

        function nextSlideInline() { if (currentSlide < slides.length - 1) { currentSlide++; updateSlideInline(); } }
        function prevSlideInline() { if (currentSlide > 0) { currentSlide--; updateSlideInline(); } }

        const nextInlineBtn = document.getElementById('slide-next-inline');
        if (nextInlineBtn) nextInlineBtn.addEventListener('click', nextSlideInline);
        const prevInlineBtn = document.getElementById('slide-prev-inline');
        if (prevInlineBtn) prevInlineBtn.addEventListener('click', prevSlideInline);
        const closeInlineBtn = document.getElementById('slide-close-inline');
        if (closeInlineBtn) closeInlineBtn.addEventListener('click', exitInlineSlides);

        // helper to open inline slide for a specific header id
        function enterInlineSlidesAtHeaderId(id) {
            const idx = slides.findIndex(s => s.id === id);
            if (idx >= 0) enterInlineSlides(idx);
        }

        loadConfig();

        const toggleMdFilesButton = document.getElementById('toggle-md-files');
        toggleMdFilesButton.addEventListener('click', () => {
            const sidebar = document.getElementById('sidebar');
            // toggle visual open state on button
            toggleMdFilesButton.classList.toggle('open');
            toggleMdFilesButton.setAttribute('aria-expanded', String(toggleMdFilesButton.classList.contains('open')));

            if (window.innerWidth <= 1200) {
                sidebar.classList.toggle('overlay');
                sidebar.classList.toggle('visible');
            } else {
                const nowHidden = sidebar.style.display === 'none';
                sidebar.style.display = nowHidden ? 'block' : 'none';
            }
        });

        const toggleTocButton = document.getElementById('toc-toggle');
        toggleTocButton.addEventListener('click', () => {
            const tocSidebar = document.getElementById('toc-sidebar');
            toggleTocButton.classList.toggle('open');
            toggleTocButton.setAttribute('aria-expanded', String(toggleTocButton.classList.contains('open')));
            if (window.innerWidth <= 1200) {
                tocSidebar.classList.toggle('overlay');
                tocSidebar.classList.toggle('visible');
            } else {
                tocSidebar.style.display = tocSidebar.style.display === 'none' ? 'block' : 'none';
            }
        });

// Hide TOC sidebar when clicking anywhere outside of it
        document.addEventListener('click', (event) => {
            const tocSidebar = document.getElementById('toc-sidebar');
            const toggleTocButton = document.getElementById('toc-toggle');
            const isClickInsideTocSidebar = tocSidebar.contains(event.target);
            const isClickOnToggleTocButton = toggleTocButton.contains(event.target);

            if (!isClickInsideTocSidebar && !isClickOnToggleTocButton && window.innerWidth <= 1200 && tocSidebar.classList.contains('visible')) {
                tocSidebar.classList.remove('overlay');
                tocSidebar.classList.remove('visible');
                const tocToggleBtn = document.getElementById('toc-toggle');
                if (tocToggleBtn) { tocToggleBtn.classList.remove('open'); tocToggleBtn.setAttribute('aria-expanded', 'false'); }
            }
        });

        document.getElementById('sidebar').addEventListener('click', (event) => {
        if (event.target.tagName === 'A') {
            const sidebar = document.getElementById('sidebar');
            if (window.innerWidth <= 1200 ) {
                sidebar.classList.remove('overlay');
                sidebar.classList.remove('visible');
                sidebar.style.transition = 'transform 0.9s ease';
                const mdToggleBtn = document.getElementById('toggle-md-files');
                if (mdToggleBtn) { mdToggleBtn.classList.remove('open'); mdToggleBtn.setAttribute('aria-expanded', 'false'); }
            }
        }
    });

    </script>
</body>
</html>
